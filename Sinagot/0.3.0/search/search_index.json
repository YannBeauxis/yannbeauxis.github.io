{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sinagot Sinagot is a Python library to batch multiple scripts on a file-system dataset with a simple API. Parallelization of data processing is made possible by Dask.distributed . Installation Sinagot is available on PyPi: pip install sinagot Full Documentation https://sinagot.readthedocs.io Concept Sinagot main class is build around the sinagot.Workspace class. To create an instance, you must provide 3 pathes to : A configuration file in .toml format. A data folder. A scripts fodler. Dataset is structured as a collection of records . A record is identified by an unique ID but many files can be generated for a single record. Those files are processed with scripts which generate other files as results. Basic example Harbor workspace You can find in \"example\" folder of the git the harbor workspace that has a record per day of a harbor occupancy. In this example, a record is created each day to count the boats that occupy the harbor. The record ID include a timestamp for the day of recording. In Unix environment, you can that type this to get the workspace : wget -qO- https://github.com/YannBeauxis/sinagot/raw/master/example/harbor.tar.gz | tar xvz To create the workspace instance : >>> from sinagot import Workspace >>> ws = Workspace ( '/path/to/harbor/workspace/folder' ) >>> ws < Workspace instance > Explore records You can list all records ids: >>> list ( ws . records . iter_ids ()) [ 'REC-20200602' , 'REC-20200603' , 'REC-20200601' ] Create a Record instance. For a specific record: >>> ws . records . get ( 'REC-20200603' ) < Record instance | id : REC - 20200603 > Or the first record found: >>> ws . records . first () < Record instance | id : REC - 20200602 > Records are not sort by their ids. run scripts You can run all scripts for each record of the dataset: >>> ws . steps . run () REC - 20200602 | 2020 - 08 - 20 11 : 19 : 11 , 530 | count : Init run REC - 20200602 | 2020 - 08 - 20 11 : 19 : 11 , 531 | count : Processing run REC - 20200602 | 2020 - 08 - 20 11 : 19 : 11 , 556 | count : Run finished ... REC - 20200601 | 2020 - 08 - 20 11 : 19 : 11 , 625 | mean : Init run REC - 20200601 | 2020 - 08 - 20 11 : 19 : 11 , 626 | mean : Processing run REC - 20200601 | 2020 - 08 - 20 11 : 19 : 11 , 634 | mean : Run finished Or for a single record: >>> ws . records . get ( 'REC-20200603' ) . steps . run () REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 588 | count : Init run REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 590 | count : Processing run REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 616 | count : Run finished REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 619 | mean : Init run REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 621 | mean : Processing run REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 637 | mean : Run finished More complex dataset You can handle more complexity of dataset structure with task and modality concepts. During a recording session for a single record, data can be generate for differents task and each task can generate different kind of data called modality . SoNeTAA usecase The idea of Sinagot emerged for the data management of an EEG platform called SoNeTAA : https://research.pasteur.fr/en/project/sonetaa/ . For documentation purpose SoNeTAA workspace structure will be used as example. On SoNeTAA, a record with an ID with timestamp info in this format REC-[YYMMDD]-[A-Z] , for example \"REC-200331-A\" . For a record, 3 tasks are performed: \"RS\" for Resting State \"MMN\" for MisMatch Negativity \"HDC\" for Human Dynamic Clamp. 3 modalities handle data depending of the tasks * For each tasks, \"EEG\" modality create data from ElectroEncephalogram . * A \"behavior\" modality create date only for HDC task. * A \"clinical\" modality handle data used for every task. Explore by task or modality Each record collection or single record has subscopes corresponding to their tasks and modalities accessible as attribute. For example to select only the task RS of the dataset: >>> ws . RS < RecordCollection instance | task : RS , modality : None > A dataset subscope is a RecordCollection . Or the EEG modality of a record: >>> rec . EEG < Record instance | id : REC - 200331 - A , task : None , modality : EEG > You can select a specific couple of task and modality (called unit ): >>> ws . RS . EEG < RecordCollection instance | task : RS , modality : EEG > >>> ws . EEG . RS < RecordCollection instance | task : RS , modality : EEG >","title":"Home"},{"location":"#sinagot","text":"Sinagot is a Python library to batch multiple scripts on a file-system dataset with a simple API. Parallelization of data processing is made possible by Dask.distributed .","title":"Sinagot"},{"location":"#installation","text":"Sinagot is available on PyPi: pip install sinagot","title":"Installation"},{"location":"#full-documentation","text":"https://sinagot.readthedocs.io","title":"Full Documentation"},{"location":"#concept","text":"Sinagot main class is build around the sinagot.Workspace class. To create an instance, you must provide 3 pathes to : A configuration file in .toml format. A data folder. A scripts fodler. Dataset is structured as a collection of records . A record is identified by an unique ID but many files can be generated for a single record. Those files are processed with scripts which generate other files as results.","title":"Concept"},{"location":"#basic-example","text":"","title":"Basic example"},{"location":"#harbor-workspace","text":"You can find in \"example\" folder of the git the harbor workspace that has a record per day of a harbor occupancy. In this example, a record is created each day to count the boats that occupy the harbor. The record ID include a timestamp for the day of recording. In Unix environment, you can that type this to get the workspace : wget -qO- https://github.com/YannBeauxis/sinagot/raw/master/example/harbor.tar.gz | tar xvz To create the workspace instance : >>> from sinagot import Workspace >>> ws = Workspace ( '/path/to/harbor/workspace/folder' ) >>> ws < Workspace instance >","title":"Harbor workspace"},{"location":"#explore-records","text":"You can list all records ids: >>> list ( ws . records . iter_ids ()) [ 'REC-20200602' , 'REC-20200603' , 'REC-20200601' ] Create a Record instance. For a specific record: >>> ws . records . get ( 'REC-20200603' ) < Record instance | id : REC - 20200603 > Or the first record found: >>> ws . records . first () < Record instance | id : REC - 20200602 > Records are not sort by their ids.","title":"Explore records"},{"location":"#run-scripts","text":"You can run all scripts for each record of the dataset: >>> ws . steps . run () REC - 20200602 | 2020 - 08 - 20 11 : 19 : 11 , 530 | count : Init run REC - 20200602 | 2020 - 08 - 20 11 : 19 : 11 , 531 | count : Processing run REC - 20200602 | 2020 - 08 - 20 11 : 19 : 11 , 556 | count : Run finished ... REC - 20200601 | 2020 - 08 - 20 11 : 19 : 11 , 625 | mean : Init run REC - 20200601 | 2020 - 08 - 20 11 : 19 : 11 , 626 | mean : Processing run REC - 20200601 | 2020 - 08 - 20 11 : 19 : 11 , 634 | mean : Run finished Or for a single record: >>> ws . records . get ( 'REC-20200603' ) . steps . run () REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 588 | count : Init run REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 590 | count : Processing run REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 616 | count : Run finished REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 619 | mean : Init run REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 621 | mean : Processing run REC - 20200603 | 2020 - 08 - 20 11 : 28 : 32 , 637 | mean : Run finished","title":"run scripts"},{"location":"#more-complex-dataset","text":"You can handle more complexity of dataset structure with task and modality concepts. During a recording session for a single record, data can be generate for differents task and each task can generate different kind of data called modality .","title":"More complex dataset"},{"location":"#sonetaa-usecase","text":"The idea of Sinagot emerged for the data management of an EEG platform called SoNeTAA : https://research.pasteur.fr/en/project/sonetaa/ . For documentation purpose SoNeTAA workspace structure will be used as example. On SoNeTAA, a record with an ID with timestamp info in this format REC-[YYMMDD]-[A-Z] , for example \"REC-200331-A\" . For a record, 3 tasks are performed: \"RS\" for Resting State \"MMN\" for MisMatch Negativity \"HDC\" for Human Dynamic Clamp. 3 modalities handle data depending of the tasks * For each tasks, \"EEG\" modality create data from ElectroEncephalogram . * A \"behavior\" modality create date only for HDC task. * A \"clinical\" modality handle data used for every task.","title":"SoNeTAA usecase"},{"location":"#explore-by-task-or-modality","text":"Each record collection or single record has subscopes corresponding to their tasks and modalities accessible as attribute. For example to select only the task RS of the dataset: >>> ws . RS < RecordCollection instance | task : RS , modality : None > A dataset subscope is a RecordCollection . Or the EEG modality of a record: >>> rec . EEG < Record instance | id : REC - 200331 - A , task : None , modality : EEG > You can select a specific couple of task and modality (called unit ): >>> ws . RS . EEG < RecordCollection instance | task : RS , modality : EEG > >>> ws . EEG . RS < RecordCollection instance | task : RS , modality : EEG >","title":"Explore by task or modality"},{"location":"configuration_file/","text":"TOML format The configuration file is in .toml : format https://github.com/toml-lang/toml File Name The default file name is workspace.toml you can use a custom name if you specify it in configuration path : Worspace ( \"folder_path/cusom_conf_name.toml\" ) Required sections records id_pattern is a regex pattern for record ID matching. For example : [records] id_pattern = \"REC-[\\\\d]{8}\" steps scripts List scripts name (without .py extension) to run in execution order. All scripts must correspond to ha ve in script folder [steps] scripts = [\"count\", \"mean\"] Optional sections path If you want to use custom path. Default is : [path] dataset = './dataset' scripts = './scripts' run If you want to use main process or Dask plugin. Default is : [run] mode = \"main_process\" log To customize logger. Default is : [log] name = \"sinagot\" format = \"%(asctime)s : %(message)s\" level = 'INFO' Advanced sections If you use tasks and modalities, you must provide tasks and modalities sections. tasks [tasks] [tasks.RS] modalities = [\"clinical\", \"EEG\"] [tasks.MMN] modalities = [\"clinical\", \"EEG\"] [tasks.HDC] modalities = [\"clinical\", \"EEG\", \"behavior\"] modalities [modalities] [modalities.EEG] scripts = ['preprocess'] task_scripts . RS = ['RS_alpha', 'RS_alpha_plot', \"RS_PSD\"] task_scripts . MMN = ['MMN_amplitude_latency', 'MMN_plot'] task_scripts . HDC = [\"HDC_PSD\"] [modalities.behavior] scripts = ['scores', 'scores_norm', 'plot_scores'] [modalities.clinical] models . plugin = \"pandas\" models . dataframe_path = ['CLINICAL', 'data.csv'] [modalities.report] models . dataframe_path = ['CLINICAL', 'data.csv'] processed Optionaly you can specify processed data : [processed] [processed.RS_alpha] task = \"RS\" modality = \"EEG\" step_label = \"RS_alpha\" path_label = \"data\" data_type = \"float\" [processed.behavior_raw_scores] task = \"HDC\" modality = \"behavior\" step_label = \"scores\" data_getter = \"dataframe_from_csv\" [processed.MMN_amplitude_latency] task = \"MMN\" modality = \"EEG\" step_label = \"MMN_amplitude_latency\" data_getter = \"series_from_csv\" path_label = \"data\"","title":"Configuration file"},{"location":"configuration_file/#toml-format","text":"The configuration file is in .toml : format https://github.com/toml-lang/toml","title":"TOML format"},{"location":"configuration_file/#file-name","text":"The default file name is workspace.toml you can use a custom name if you specify it in configuration path : Worspace ( \"folder_path/cusom_conf_name.toml\" )","title":"File Name"},{"location":"configuration_file/#required-sections","text":"","title":"Required sections"},{"location":"configuration_file/#records","text":"id_pattern is a regex pattern for record ID matching. For example : [records] id_pattern = \"REC-[\\\\d]{8}\"","title":"records"},{"location":"configuration_file/#steps","text":"scripts List scripts name (without .py extension) to run in execution order. All scripts must correspond to ha ve in script folder [steps] scripts = [\"count\", \"mean\"]","title":"steps"},{"location":"configuration_file/#optional-sections","text":"","title":"Optional sections"},{"location":"configuration_file/#path","text":"If you want to use custom path. Default is : [path] dataset = './dataset' scripts = './scripts'","title":"path"},{"location":"configuration_file/#run","text":"If you want to use main process or Dask plugin. Default is : [run] mode = \"main_process\"","title":"run"},{"location":"configuration_file/#log","text":"To customize logger. Default is : [log] name = \"sinagot\" format = \"%(asctime)s : %(message)s\" level = 'INFO'","title":"log"},{"location":"configuration_file/#advanced-sections","text":"If you use tasks and modalities, you must provide tasks and modalities sections.","title":"Advanced sections"},{"location":"configuration_file/#tasks","text":"[tasks] [tasks.RS] modalities = [\"clinical\", \"EEG\"] [tasks.MMN] modalities = [\"clinical\", \"EEG\"] [tasks.HDC] modalities = [\"clinical\", \"EEG\", \"behavior\"]","title":"tasks"},{"location":"configuration_file/#modalities","text":"[modalities] [modalities.EEG] scripts = ['preprocess'] task_scripts . RS = ['RS_alpha', 'RS_alpha_plot', \"RS_PSD\"] task_scripts . MMN = ['MMN_amplitude_latency', 'MMN_plot'] task_scripts . HDC = [\"HDC_PSD\"] [modalities.behavior] scripts = ['scores', 'scores_norm', 'plot_scores'] [modalities.clinical] models . plugin = \"pandas\" models . dataframe_path = ['CLINICAL', 'data.csv'] [modalities.report] models . dataframe_path = ['CLINICAL', 'data.csv']","title":"modalities"},{"location":"configuration_file/#processed","text":"Optionaly you can specify processed data : [processed] [processed.RS_alpha] task = \"RS\" modality = \"EEG\" step_label = \"RS_alpha\" path_label = \"data\" data_type = \"float\" [processed.behavior_raw_scores] task = \"HDC\" modality = \"behavior\" step_label = \"scores\" data_getter = \"dataframe_from_csv\" [processed.MMN_amplitude_latency] task = \"MMN\" modality = \"EEG\" step_label = \"MMN_amplitude_latency\" data_getter = \"series_from_csv\" path_label = \"data\"","title":"processed"},{"location":"API/record/","text":"Record A Record instance is used to manipulate a single record data. It's accessed from a RecordCollection . Note Inherite Scope methods. Example: rec = ws . get ( \"RECORD-ID\" ) # ws is a Workspace instance logs ( self ) Returns: Type Description DataFrame Logs history. logs_json ( self ) status_dict ( self ) Returns: Type Description str Status in dict format. status_json ( self ) Returns: Type Description str Status in JSON format for web API.","title":"Record"},{"location":"API/record/#record","text":"","title":"Record"},{"location":"API/record/#sinagot.models.record.Record","text":"A Record instance is used to manipulate a single record data. It's accessed from a RecordCollection . Note Inherite Scope methods. Example: rec = ws . get ( \"RECORD-ID\" ) # ws is a Workspace instance","title":"sinagot.models.record.Record"},{"location":"API/record/#sinagot.models.record.Record.logs","text":"Returns: Type Description DataFrame Logs history.","title":"logs()"},{"location":"API/record/#sinagot.models.record.Record.logs_json","text":"","title":"logs_json()"},{"location":"API/record/#sinagot.models.record.Record.status_dict","text":"Returns: Type Description str Status in dict format.","title":"status_dict()"},{"location":"API/record/#sinagot.models.record.Record.status_json","text":"Returns: Type Description str Status in JSON format for web API.","title":"status_json()"},{"location":"API/record_collection/","text":"RecordCollection A RecordCollection is used to manipulate a collection of Record . Note Inherite Scope methods. Example: # access record_collection of all EEG records (EEG is a task) sub = ws . EEG # ws is a Workspace instance __init__ ( self , * args , ** kwargs ) special Parameters: Name Type Description Default workspace Root Workspace. required task Task of the scope. required modality Modality of the scope. required get ( self , record_id ) Get record by ID. Parameters: Name Type Description Default record_id str record ID required Returns: Type Description Record Record instance iter_ids ( self ) Generator all record ids within the record_collection. Returns: Type Description Generator[str, NoneType, NoneType] Record ID. logs ( self ) Returns: Type Description DataFrame Logs history.","title":"RecordCollection"},{"location":"API/record_collection/#recordcollection","text":"","title":"RecordCollection"},{"location":"API/record_collection/#sinagot.models.record_collection.RecordCollection","text":"A RecordCollection is used to manipulate a collection of Record . Note Inherite Scope methods. Example: # access record_collection of all EEG records (EEG is a task) sub = ws . EEG # ws is a Workspace instance","title":"sinagot.models.record_collection.RecordCollection"},{"location":"API/record_collection/#sinagot.models.record_collection.RecordCollection.__init__","text":"Parameters: Name Type Description Default workspace Root Workspace. required task Task of the scope. required modality Modality of the scope. required","title":"__init__()"},{"location":"API/record_collection/#sinagot.models.record_collection.RecordCollection.get","text":"Get record by ID. Parameters: Name Type Description Default record_id str record ID required Returns: Type Description Record Record instance","title":"get()"},{"location":"API/record_collection/#sinagot.models.record_collection.RecordCollection.iter_ids","text":"Generator all record ids within the record_collection. Returns: Type Description Generator[str, NoneType, NoneType] Record ID.","title":"iter_ids()"},{"location":"API/record_collection/#sinagot.models.record_collection.RecordCollection.logs","text":"Returns: Type Description DataFrame Logs history.","title":"logs()"},{"location":"API/scope/","text":"Scope A Scope instance can : Handle task and modality subscopes. Handle StepCollection with .steps attribute. Note Scope is base class for RecordCollection and Record . is_unit: bool property readonly Check if has both task and modality not None . modality: Optional [ str ] Modality of the scope. If None , the scope represents all available modalities. task: Optional [ str ] Task of the scope. If None , the scope represents all available tasks. __init__ ( self , workspace , task = None , modality = None ) special Parameters: Name Type Description Default workspace Workspace Root Workspace. required task Optional[str] Task of the scope. None modality Optional[str] Modality of the scope. None count_raw_data ( self , * args , ** kwargs ) count_step ( self , step_label = None , position = 'input' , * args , ** kwargs ) get_subscope ( self , task = None , modality = None ) Get subscope for given task and/or modality Parameters: Name Type Description Default task Optional[str] the task target None modality Optional[str] the modality target None Returns: Type Description Scope iter_modalities ( self ) Generate subscopes of the current scope for each of its modalities. Returns: Type Description Generator[Scope, NoneType, NoneType] Subscope with a modality attribute. iter_tasks ( self ) Generate subscopes of the current scope for each of its task. Returns: Type Description Generator[Scope, NoneType, NoneType] Subscope with a task attribute. iter_units ( self ) Generate each 'unit' subscopes of the current scope, i.e. subscope with specific task and modality Returns: Type Description Generator[Scope, NoneType, NoneType] Subscope with a task attribute.","title":"Scope"},{"location":"API/scope/#scope","text":"","title":"Scope"},{"location":"API/scope/#sinagot.models.scope.Scope","text":"A Scope instance can : Handle task and modality subscopes. Handle StepCollection with .steps attribute. Note Scope is base class for RecordCollection and Record .","title":"sinagot.models.scope.Scope"},{"location":"API/scope/#sinagot.models.scope.Scope.is_unit","text":"Check if has both task and modality not None .","title":"is_unit"},{"location":"API/scope/#sinagot.models.scope.Scope.modality","text":"Modality of the scope. If None , the scope represents all available modalities.","title":"modality"},{"location":"API/scope/#sinagot.models.scope.Scope.task","text":"Task of the scope. If None , the scope represents all available tasks.","title":"task"},{"location":"API/scope/#sinagot.models.scope.Scope.__init__","text":"Parameters: Name Type Description Default workspace Workspace Root Workspace. required task Optional[str] Task of the scope. None modality Optional[str] Modality of the scope. None","title":"__init__()"},{"location":"API/scope/#sinagot.models.scope.Scope.count_raw_data","text":"","title":"count_raw_data()"},{"location":"API/scope/#sinagot.models.scope.Scope.count_step","text":"","title":"count_step()"},{"location":"API/scope/#sinagot.models.scope.Scope.get_subscope","text":"Get subscope for given task and/or modality Parameters: Name Type Description Default task Optional[str] the task target None modality Optional[str] the modality target None Returns: Type Description Scope","title":"get_subscope()"},{"location":"API/scope/#sinagot.models.scope.Scope.iter_modalities","text":"Generate subscopes of the current scope for each of its modalities. Returns: Type Description Generator[Scope, NoneType, NoneType] Subscope with a modality attribute.","title":"iter_modalities()"},{"location":"API/scope/#sinagot.models.scope.Scope.iter_tasks","text":"Generate subscopes of the current scope for each of its task. Returns: Type Description Generator[Scope, NoneType, NoneType] Subscope with a task attribute.","title":"iter_tasks()"},{"location":"API/scope/#sinagot.models.scope.Scope.iter_units","text":"Generate each 'unit' subscopes of the current scope, i.e. subscope with specific task and modality Returns: Type Description Generator[Scope, NoneType, NoneType] Subscope with a task attribute.","title":"iter_units()"},{"location":"API/script/","text":"Script Template class for scripts. You must override PATH_IN , PATH_OUT and run() to use it. Usage From harbor example : import pandas as pd from sinagot import ScriptTemplate class Script ( ScriptTemplate ): PATH_IN = ( \"raw\" , \"{id}-raw.csv\" ) PATH_OUT = ( \"computed\" , \"{id}-count.csv\" ) def run ( self ): df = pd . read_csv ( self . path . input ) df = df . groupby ( \"country\" ) . count () df . to_csv ( self . path . output ) data_exist property readonly Get named tuple of boolean to check if input and output data exist. data_path The path to dataset id The record ID label The step label modality class-attribute The modality label opts Optional dict PATH_CONTROL class-attribute Tuple or dict of tuples to specify control path pattern. Control path can be used to generate additional data or graph in case of bad qualtiy results or errors. PATH_IN class-attribute Tuple or dict of tuples to specify input path pattern PATH_OUT class-attribute Tuple or dict of tuples to specify output path pattern status Status of the script during its run. Valuse are defined in sinagot.utils.StepStatus class task The modality label __init__ ( self , data_path , record_id , task = None , opts = {}, logger_namespace = None , workspace_version = None ) special run ( self ) Main method called during step run.","title":"Script"},{"location":"API/script/#script","text":"","title":"Script"},{"location":"API/script/#sinagot.script.ScriptTemplate","text":"Template class for scripts. You must override PATH_IN , PATH_OUT and run() to use it. Usage From harbor example : import pandas as pd from sinagot import ScriptTemplate class Script ( ScriptTemplate ): PATH_IN = ( \"raw\" , \"{id}-raw.csv\" ) PATH_OUT = ( \"computed\" , \"{id}-count.csv\" ) def run ( self ): df = pd . read_csv ( self . path . input ) df = df . groupby ( \"country\" ) . count () df . to_csv ( self . path . output )","title":"sinagot.script.ScriptTemplate"},{"location":"API/script/#sinagot.script.ScriptTemplate.data_exist","text":"Get named tuple of boolean to check if input and output data exist.","title":"data_exist"},{"location":"API/script/#sinagot.script.ScriptTemplate.data_path","text":"The path to dataset","title":"data_path"},{"location":"API/script/#sinagot.script.ScriptTemplate.id","text":"The record ID","title":"id"},{"location":"API/script/#sinagot.script.ScriptTemplate.label","text":"The step label","title":"label"},{"location":"API/script/#sinagot.script.ScriptTemplate.modality","text":"The modality label","title":"modality"},{"location":"API/script/#sinagot.script.ScriptTemplate.opts","text":"Optional dict","title":"opts"},{"location":"API/script/#sinagot.script.ScriptTemplate.PATH_CONTROL","text":"Tuple or dict of tuples to specify control path pattern. Control path can be used to generate additional data or graph in case of bad qualtiy results or errors.","title":"PATH_CONTROL"},{"location":"API/script/#sinagot.script.ScriptTemplate.PATH_IN","text":"Tuple or dict of tuples to specify input path pattern","title":"PATH_IN"},{"location":"API/script/#sinagot.script.ScriptTemplate.PATH_OUT","text":"Tuple or dict of tuples to specify output path pattern","title":"PATH_OUT"},{"location":"API/script/#sinagot.script.ScriptTemplate.status","text":"Status of the script during its run. Valuse are defined in sinagot.utils.StepStatus class","title":"status"},{"location":"API/script/#sinagot.script.ScriptTemplate.task","text":"The modality label","title":"task"},{"location":"API/script/#sinagot.script.ScriptTemplate.__init__","text":"","title":"__init__()"},{"location":"API/script/#sinagot.script.ScriptTemplate.run","text":"Main method called during step run.","title":"run()"},{"location":"API/step/","text":"Step id property readonly __init__ ( self , script , model ) special logs ( self ) Returns: Type Description DataFrame Logs history. run ( self , force = False , ignore_missing = False , debug = False ) Run the step script. Parameters: Name Type Description Default force Optional[bool] Force run and overwrites result file(s) if already exist(s). False status ( self ) Get status code. Returns: Type Description int sinagot.utils.StepStatus value","title":"Step"},{"location":"API/step/#step","text":"","title":"Step"},{"location":"API/step/#sinagot.models.step.Step","text":"","title":"sinagot.models.step.Step"},{"location":"API/step/#sinagot.models.step.Step.id","text":"","title":"id"},{"location":"API/step/#sinagot.models.step.Step.__init__","text":"","title":"__init__()"},{"location":"API/step/#sinagot.models.step.Step.logs","text":"Returns: Type Description DataFrame Logs history.","title":"logs()"},{"location":"API/step/#sinagot.models.step.Step.run","text":"Run the step script. Parameters: Name Type Description Default force Optional[bool] Force run and overwrites result file(s) if already exist(s). False","title":"run()"},{"location":"API/step/#sinagot.models.step.Step.status","text":"Get status code. Returns: Type Description int sinagot.utils.StepStatus value","title":"status()"},{"location":"API/step_collection/","text":"StepCollection Manage the collection of all steps of a scope. __init__ ( self , model ) special count ( self ) Get the number of steps. Returns: Type Description Union[int, dict] int if model has modality, dict with step count as value for each modality either. first ( self ) Get the first step. Returns: Type Description Union[sinagot.models.step.Step, dict] Step if model has modality, dict with first step as value for each modality either. get ( self , script_name ) find a step by script name. Parameters: Name Type Description Default script_name str script label to find. required Returns: Type Description Union[sinagot.models.step.Step, dict] Step if model has modality, dict with Step or None as value for each modality either. scripts_names ( self )","title":"StepCollection"},{"location":"API/step_collection/#stepcollection","text":"","title":"StepCollection"},{"location":"API/step_collection/#sinagot.models.step_collection.StepCollection","text":"Manage the collection of all steps of a scope.","title":"sinagot.models.step_collection.StepCollection"},{"location":"API/step_collection/#sinagot.models.step_collection.StepCollection.__init__","text":"","title":"__init__()"},{"location":"API/step_collection/#sinagot.models.step_collection.StepCollection.count","text":"Get the number of steps. Returns: Type Description Union[int, dict] int if model has modality, dict with step count as value for each modality either.","title":"count()"},{"location":"API/step_collection/#sinagot.models.step_collection.StepCollection.first","text":"Get the first step. Returns: Type Description Union[sinagot.models.step.Step, dict] Step if model has modality, dict with first step as value for each modality either.","title":"first()"},{"location":"API/step_collection/#sinagot.models.step_collection.StepCollection.get","text":"find a step by script name. Parameters: Name Type Description Default script_name str script label to find. required Returns: Type Description Union[sinagot.models.step.Step, dict] Step if model has modality, dict with Step or None as value for each modality either.","title":"get()"},{"location":"API/step_collection/#sinagot.models.step_collection.StepCollection.scripts_names","text":"","title":"scripts_names()"},{"location":"API/workspace/","text":"Workspace Workspace is the main class to handle dataset and scripts. It required a configuration file in .toml format. You can access to the RecordCollection of the dataset with .records property. You can access to the StepCollection of the scripts with .steps property. Usage Create an instance : from sinagot import Workspace ws = Workspace ( path / to / config . toml ) data_path: Path property readonly Path of data folder info property readonly records: RecordCollection property readonly RecordCollection of all records of the workspace scripts_path: Path property readonly Path of all the scripts folder steps: StepCollection property readonly StepCollecion for all steps of the workspace version property readonly __init__ ( self , config_path , data_path = None , scripts_path = None ) special Parameters: Name Type Description Default config_path Union[str, pathlib.Path, list, tuple] path to the config file(s) in toml. required data_path Optional[Union[str, pathlib.Path]] path to the folder of the workspace. None close ( self )","title":"Workspace"},{"location":"API/workspace/#workspace","text":"","title":"Workspace"},{"location":"API/workspace/#sinagot.models.workspace.Workspace","text":"Workspace is the main class to handle dataset and scripts. It required a configuration file in .toml format. You can access to the RecordCollection of the dataset with .records property. You can access to the StepCollection of the scripts with .steps property. Usage Create an instance : from sinagot import Workspace ws = Workspace ( path / to / config . toml )","title":"sinagot.models.workspace.Workspace"},{"location":"API/workspace/#sinagot.models.workspace.Workspace.data_path","text":"Path of data folder","title":"data_path"},{"location":"API/workspace/#sinagot.models.workspace.Workspace.info","text":"","title":"info"},{"location":"API/workspace/#sinagot.models.workspace.Workspace.records","text":"RecordCollection of all records of the workspace","title":"records"},{"location":"API/workspace/#sinagot.models.workspace.Workspace.scripts_path","text":"Path of all the scripts folder","title":"scripts_path"},{"location":"API/workspace/#sinagot.models.workspace.Workspace.steps","text":"StepCollecion for all steps of the workspace","title":"steps"},{"location":"API/workspace/#sinagot.models.workspace.Workspace.version","text":"","title":"version"},{"location":"API/workspace/#sinagot.models.workspace.Workspace.__init__","text":"Parameters: Name Type Description Default config_path Union[str, pathlib.Path, list, tuple] path to the config file(s) in toml. required data_path Optional[Union[str, pathlib.Path]] path to the folder of the workspace. None","title":"__init__()"},{"location":"API/workspace/#sinagot.models.workspace.Workspace.close","text":"","title":"close()"}]}